# Crivo de Erat√≥stenes

## üìö Introdu√ß√£o

O crivo de Erat√≥stenes √© um algoritmo que permite encontrar todos os n√∫meros primos at√© um determinado n√∫mero `n`.

## ü§∑ Como funciona?

Pense no seguinte problema, dado um n√∫mero Q, devemos responder para cada n√∫mero de 0 at√© Q-1 se ele √© ou n√£o √© primo, por exemplo se Q = 100, precisamos responder para todo n√∫mero de 0 at√© 99 se eles s√£o primos. Como podemos resolver esse problema?

Uma solu√ß√£o ing√™nua seria, para cada um dos Q n√∫meros (chamamos tal n√∫mero de N), testar se ele √© divis√≠vel por algum n√∫mero de 2 at√© N-1, por exemplo:

```cpp
bool eh_primo(int n) {
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```

Esse algoritmo funciona, mas ele √© muito lento, pois para cada um dos Q n√∫meros, ele testa todos os n√∫meros de 2 at√© N-1, o que resulta em uma complexidade de `O(Q*N)`.

Podemos melhorar esse algoritmo, se percebermos que n√£o precisamos testar todos os n√∫meros de 2 at√© N-1, pois se um n√∫mero `N` n√£o for divis√≠vel por nenhum n√∫mero de 2 at√© `N-1`, ent√£o ele n√£o √© divis√≠vel por nenhum n√∫mero de 2 at√© `N/2`, pois se ele fosse divis√≠vel por um n√∫mero maior que `N/2`, ele tamb√©m seria divis√≠vel por um n√∫mero menor que `N/2`.

Ent√£o podemos melhorar o algoritmo da seguinte forma:

```cpp
bool eh_primo(int n) {
    for (int i = 2; i < n/2; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```

Agora o algoritmo est√° um pouco mais r√°pido, mas ainda √© lento, pois para cada um dos Q n√∫meros, ele testa todos os n√∫meros de 2 at√© `N/2`, o que resulta em uma complexidade de `O(Q*N/2)`.

Podemos melhorar ainda mais esse algoritmo, se percebermos que n√£o precisamos testar todos os n√∫meros de 2 at√© `N/2`, podemos testar apenas os n√∫meros de 2 at√© a raiz quadrada de N + 1, essa √© uma propriedade bem legal da matem√°tica que nos permite reduzir a complexidade ainda mais.

O c√≥digo ficaria da seguinte forma:

```cpp
#include <cmath>

bool eh_primo(int n) {
    for (int i = 2; i < sqrt(n)+1; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```

Agora o algoritmo est√° bem mais r√°pido, com uma complexidade de `O(Q*sqrt(N))`, por√©m para um n√∫mero Q muito grande, esse c√≥digo ainda pode demorar muito para responder para todos os N n√∫meros.

Estamos esquecendo de algo muito importante! Se um dado n√∫mero √© primo, ent√£o duas vezes esse n√∫mero n√£o √© primo, 3 vezes esse n√∫mero n√£o √© primo e assim por diante, podemos visualizar isso na anima√ß√£o abaixo:

<figure><img src="../assets/crivo.gif" alt="Anima√ß√£o de n√∫meros primos"><figcaption></figcaption></figure>

Podemos aplicar isso da seguinte forma, poder√≠amos usar um vetor e percorrer todos os n√∫meros de 2 a Q, se ele estiver marcado, o n√∫mero √© um primo, ent√£o desmarcamos todos os m√∫ltiplos desse primo menores que Q, pois eles n√£o s√£o primos.

No final, s√≥ consultamos o vetor para ver se dado n√∫mero √© primo.

O c√≥digo ficaria da seguinte forma:

```cpp
#include <vector>

using namespace std;

vector<bool> crivo(int n) {
    vector<bool> primos(n+1, true);
    primos[0] = false;  // 0 n√£o √© primo
    primos[1] = false;  // 1 n√£o √© primo
    for (int i = 2; i <= n; i++) {
        if (primos[i]) {  // se i √© primo
            for (int j = i*i; j <= n; j += i) {  // marca todos os m√∫ltiplos de i como n√£o primos
                primos[j] = false;
            }
        }
    }
    return primos;
}
```

Essa solu√ß√£o tem uma complexidade de `O(N * log(log(N)))`, sendo assim bastante r√°pida.

Para finalizar, temos que ter em mente que o Crivo de Er√°stotenes √© um algoritmo muito eficiente para encontrar todos os n√∫meros primos at√© um determinado n√∫mero, mas, temos que ter em mente que criamos uma lista com o tamanho do n√∫mero `Q`, e que fazemos m√∫ltiplas opera√ß√µes repetidas, ent√£o em casos onde voc√™ precisa responder poucas vezes se um n√∫mero √© primo ou n√£o, a solu√ß√£o ing√™nua otimizada pode ser mais eficiente.

## üßë‚Äçüè´ Exerc√≠cios

- Exerc√≠cio [1165](https://www.beecrowd.com.br/judge/pt/problems/view/1165) do Beecrowd, n√£o tem muito o que falar sobre esse exerc√≠cio, diga se um n√∫mero √© primo ou n√£o!

- Exerc√≠cio [3002](https://www.beecrowd.com.br/judge/pt/problems/view/3002) do Beecrowd, esse exerc√≠cio gira em torno de n√∫meros primos e de uma propriedade matem√°tica chamada de Conjectura de Goldbach, um problema muito interessante e que vale a pena tentar resolver!
